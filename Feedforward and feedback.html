
<!-- saved from url=(0109)https://web.archive.org/web/20240317135458fw_/https://rhordijk.home.xs4all.nl/G2Pages/FeedforwardFeedback.htm -->
<html><!--<meta version="1.0">--><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><script type="text/javascript" src="./Feedforward and feedback_files/bundle-playback.js" charset="utf-8"></script>
<script type="text/javascript" src="./Feedforward and feedback_files/wombat.js" charset="utf-8"></script>
<script>window.RufflePlayer=window.RufflePlayer||{};window.RufflePlayer.config={"autoplay":"on","unmuteOverlay":"hidden","showSwfDownload":true};</script>
<script type="text/javascript" src="./Feedforward and feedback_files/ruffle.js"></script>
<script type="text/javascript">
    __wm.init("https://web.archive.org/web");
  __wm.wombat("https://rhordijk.home.xs4all.nl/G2Pages/FeedforwardFeedback.htm","20240317135458","https://web.archive.org/","web","https://web-static.archive.org/_static/",
	      "1710683698");
</script>
<link rel="stylesheet" type="text/css" href="./Feedforward and feedback_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="./Feedforward and feedback_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->
<title>Feedforward and feedback</title>







<!--<base target="_self">--><base href="." target="_self">

<link rel="stylesheet" href="./Feedforward and feedback_files/Default.css" type="text/css">

<link rel="stylesheet" href="./Feedforward and feedback_files/IntroHistory_4835.css">


<link rel="stylesheet" href="./Feedforward and feedback_files/Custom.css" type="text/css">

<meta name="generator" content="RoboHELP by eHelp Corporation - www.ehelp.com - from RoboHelp for FrameMaker">

<link rel="next" href="https://web.archive.org/web/20240317135458fw_/https://rhordijk.home.xs4all.nl/G2Pages/Filters.htm">

<link rel="prev" href="https://web.archive.org/web/20240317135458fw_/https://rhordijk.home.xs4all.nl/G2Pages/SoundSources.htm">


</head>



<body>







<!-- Generated Text- - - - - - - - - - - - - - - - - - - - - - - - - - - - -  -->

<h2 class="pHeading1" ps="Heading1" origtag="Heading1"><a name="FeedforwardFeedback_7616_999206"></a>Feedforward and feedback</h2>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="FeedforwardFeedback_7616_999922"></a>Feedforward</h3>

<p class="pBody" ps="Body" origtag="Body">Connecting two cables at an <font class="c_Override" cs="+Override" style="font-style:italic;">output</font> of a module will create two separate signal paths coming from this output. This effectively splits a signal into two <font class="c_Override" cs="+Override" style="font-style:italic;">parallel</font> signals, that at this point are exact copies of each other. The reason one might want to do so is to give one or both signal paths a different sonic treatment. After these sonic treatments the two manipulated signals can be mixed together again. The final result will be an effect that is a combination of the two effects applied to the signal after it was split up into the two copies. This technique is named feedforward and is an important technique to create subtle effects. Using feedforward techniques is often the way to get more control over effects that are applied to already recorded sound tracks or sound samples and loops. An exampe is to first feed the copies through bandfilters set to two or more different bands and then giving different effects to these different frequency bands in the audio signal.</p>

<p class="pBody" ps="Body" origtag="Body">Spitting a signal into two signals, manipulating the two copies and then mixing them together does not necessarily have to create a simple ‘addition’ of the two applied effects. It is better to try to imagine how the two manupulated signals will later <font class="c_Override" cs="+Override" style="font-style:italic;">interfere</font> with each other. E.g., it is possible to ‘subtract’ one effect from another effect by inverting one of the signals before they are mixed together. This creates an <font class="c_Override" cs="+Override" style="font-style:italic;">interference</font> that is defined by the difference between the two applied effects. A good example is when one of the signal paths is filtered with a simple, non-resonant lowpass filter and inverted in phase, while the other signal path is left unaltered. Because what the filter is passing on is subtracted from the original signal, the output of the mixer will be a signal that contains ‘everything what the lowpass filter threw away’ from the original signal. Which are the high frequency partials in the original signal. So, this technique effectively creates an extra highpass filtering output in addition to the lowpass output of the filter. The result of this feedforward operation is that the single output lowpass filter is basically changed into a two output crossover filter effect that splits the audio spectrum into two bands. However, the highpass slope will not be of the same steepness as the lowpass slope. In practice this is not much of a problem, as the human mind will not perceive the steepness of a highpass slope as pronounced as it perceives the steepness of a lowpass slope. More important is that when the lowpass signal and the highpass signal are added together again, there will be an exact copy of the original signal. This last step might appear senseless, but when another effect like e.g. a distortion is applied to either the lowpass signal or the highpass signal before they are mixed together again, this distortion will only work on the chosen part of the spectrum and not on the other part. There are many sound manipulations that work best when they are only applied to one part of the sound spectrum. A good example is a chorus effect, which is best applied on the mid part of the sound spectrum, as chorus on low bass notes will easily sound muddy and in the very high parts of the spectrum the chorus might kill what is named ‘air’. Too much chorus in these parts of the audio spectrum will make the sound loose its definition. Another example is when odd harmonic distortion is applied to a signal. It is often best to limit this distortion to the band below 2.5kHz, in which case the distortion will seem to enhance the presence of the sound in a mix. It will also keep the high part of the sound clean of ‘intermodulation’, an effect where the high frequencies seem to be amplitude modulated by the lowest frequencies in an unnatural sounding way. In these crossover filter examples it is important that the passband of the lowpass filter passes the signal at unity gain and the mixer inputs have exactly the same sensitivity. This could pose a problem on an analog system, but with the precision of a properly designed digital system this technique works quite well and is very effective and of great practical use.</p>

<p class="pBody" ps="Body" origtag="Body">Another case of feedforward is when one or both of the signal paths are given a well-defined time delay or a phase shift. A phase shift is a frequency dependent time delay with different delay times for different partials. When the signals are mixed together later, the interference can create a dramatic change in the timbre of the processed sound. This is caused by the fact that some partials will be delayed in a way that they will become in phase with the same partials in the other path, and so boost these partials in the final mixing. Other partials might be delayed in a way that they will be in anti-phase with their counterparts in the other path, and so cancel each other out and simply disappear into thin air. The basic purpose of this type of feedforward can be understood as creating an interference effect on the different partials in the sound, with the aim to change the timbre. The interference can be made to be dynamic, meaning that the manipulation of one of the copies of the original signal is controlled by a continuously evolving modulation signal. This will make the resulting interference pattern change in a lively way. Many popular effects like chorusing, comb filtering, flanging and phasing are based on this principle. This technique is also very interesting when two filter modules are placed in parallel. An example is when.two lowpass filters are patched in parallel and their outputs are subtracted in equal parts from each other, which will create a bandpass filter. The advantage of using two parallel lowpass filters over using a lowpass and a highpass filter in series is that it doesn’t matter which filter is tuned higher, there will always be a passband between the two set cutoff frequencies. Additionally it is possible to morph from a lowpass response to a bandpass response by slowly fading in the output of one of the filters on its final mixer input. With a lowpass/highpass combination in series it works out a bit different, as when the highpass filter is accidentally tuned higher as the lowpass filter most of the sound will disappear, while with two parallel lowpass filters the sound will not disappear but simply reverse in phase. Also, morphing from lowpass to bandpass is less straightforward with a lowpass and highpass in series, which would involve a crossfader over the highpass.</p>

<p class="pBody" ps="Body" origtag="Body">It is very important that there are no unwanted inherent delays in the two signal paths caused by the order in which modules are calculated by the digital system. On many modular softsynth software packages that run on computers this might pose problems, due to the fact that these packages tend to have modules process on whole blocks of samples before output is passed on to other modules. If so, feedforward might not be sample accurate anymore and the module’s input to output propagation delay will cause unpredictable results. However, modules on DSP-based systems like the G2 are calculated one sample at a time, making feedforward sample accurate and quite easy to work with. Additionally, the G2 system employs a very sophisticated algorithm to ensure that the calculation order of the modules is automatically set in the proper order. This algorithm ensures that the output value of an earlier module in a signal path is already calculated and available for the following modules in the same path. Such an algorithm is not simple, as signals can branch into several directions and all cabling connections need to be analysed to reorder the calculation order when a new module is inserted into a chain of modules or new cable connections are made. This means that insertion of a module or reconnection of a cable briefly silences the patch when a new order of calculation is necessary and the modules will be reordered. This only happens at patchtime, when a patch is set up, or on the moment when a patch is reloaded from patch memory.</p>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="FeedforwardFeedback_7616_1000089"></a>Convolution</h3>

<p class="pBody" ps="Body" origtag="Body">Convolution is an advanced application of feedforward. Basically a signal is split into a multitude of feedforward paths that each have a different delay. These delays range from one sample, two samples, three samples, and on and on, until an n-th sample. Then, each delayed path is fed into a mixer with n inputs channels. In essence convolution uses a block of consequetive memory locations as a multi-tap delay line, and each memory location in the delay line is connected to one input of a multi-input mixer. By setting all the mixer faders to specific individual settings, all sorts of advanced effects can be created. Examples are filtering by an arbitrary filter curve, realistic reverberation by the superimposition of the reflection characteristics of a certain room on a sound, the superimposition of the timbre of a certain sound over another sound, pitch correction, etc. Regrettably one needs a really huge amount of mixing channels, and the fader setting of each individual channel is very critical to get a certain final result. Note that when a convolution is made of the last second of sound all samples from this last second will be used, meaning that convolution easily takes up much of the computational resources. E.g., when the sample rate is 96kHz and a mono reverberation of only half a second is the aim, 48000 feedforward taps on a delayline to 48000 mixer inputs plus their specific fader settings are necessary. The only way to work practically with this technique is to have a computer calculate the fader settings and do all the feedforward and mixing in software. Note that at a sample rate of 96kHz 48000 calculations have to be made for only one single sample for a 0.5 second reverb effect and a total of 96000 times 48000 calculations would be necessary. This means that really powerful computers are needed to do such operations in real time. But if such a powerful system is available the effect will be very convincing. In practice these sort of effects are mostly rendered off-line on an audio file or an already recorded track.</p>

<p class="pBody" ps="Body" origtag="Body">When using convolution for filtering the situation is less severe, as only the amount of samples that just fit in one waveform cycle of the lowest frequency to be filtered are needed. If the lowest frequency to be affected by the filtering is 100Hz only 96kHz/100Hz = 960 calculations are needed. Within the bandwidth between this 100Hz and the upper frequency limit of the ear, any filtering curve can be made with such a filter. Still, there are 960 fader setting parameters to make, to define the filtering curve. Again a computer program will be needed to calculate these settings. Convolution is a very powerful technique, but as it needs an enormous amount of control data it is hard to use in realtime with dynamic control. It goes way beyond the practical purpose of this book to go deep into all the possible convolution techniques and why convolution works at all. Still, convolution is mentioned to show how important and powerful feedforward as a technique actually can be.</p>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="FeedforwardFeedback_7616_1000148"></a>Convolution on control signals</h3>

<p class="pBody" ps="Body" origtag="Body">The amount of control data and calculations involved in convolution depends on the time duration of the convolution plus the sample rate. For audio it can be quite a large number. Still, it is always interesting to see if there are processes that are run at a much slower rate. Sequencing notes is a good example of a process that runs at quite a low rate. Convolution can be conveniently used to modify the static pattern of an analog style step sequencer without destroying the programmed pattern. Only a few delayed steps are necessary to be able to slowly variate the pattern in a controlled manner with four to five knobs. In most cases a step sequencer will have one single step output for the current step, and an extra multiple tap delayline in the form of a shift register is necessary to give access to the other steps in the proper time-delayed order. When the convolved pattern must play notes in a certain scale an extra note quantizer module must be used to force the convolved pattern output back on the wanted note or chord scale. On an analog modular synthesizer the shift register would have to be patched from a couple of sample and hold modules put in series and clocked by the same clock as the step sequencer. The G2 system has an eight output shift register present as a dedicated module, which can be clocked by the step sequencer clock signal.</p>

<p class="pBody" ps="Body" origtag="Body">There are two ways to go about using the shift register to convolve a pattern from the step sequencer, an asymmetrical or a symmetrical convolution. The asymmetrical convolution simply has a multi-input mixer connected to all the taps of the delay line. When only one mixer channel is fully opened the pattern will come out unchanged, but with a delay of some steps that depends on which tap the mixer channel is connected to. When more mixer channels are opened the pattern will be filtered, resulting in smaller steps between the adjacent notes in the original pattern. To still be able to have relatively large steps the mixers channels should be able to also invert their input values. To do so it is often more handy to use bipolar gain controllers before each channel input and control these gain controllers with a bipolar control value. The pattern is varied interactively by playing with the knobs that set the bipolar control values.</p>

<p class="pBody" ps="Body" origtag="Body">The symmetrical convolution uses an odd number of taps. The taps are located symmetrically around a center tap. Sets of two taps are first mixed together before they go to the final mixer. When seven taps are used it is tap number 1 plus 7, 2 plus 6 and 3 plus 5 that are combined, while the center tap number 4 gets its own mixer channel. The middle tap is connected to the first input of the final mixer, tap 3-5 to the second, tap 2-6 to the third and finally tap1-7 to the fourth mixer input. The way to get the original pattern is by fully opening the first mixer channel that is connected to the first input of the mixer. This does however delay the sequence by four steps. Symmetrical convolution creates different sorts of pattern variations compared to asymmetrical convolution, asymmetrical convolution appears more like a canon or echo effect.</p>

<p class="pBody" ps="Body" origtag="Body">Instead of using a step sequencer to produce the pattern to convolve a low frequency generator can be used. By just playing with the rate control different patterns can be produced, the convolution will transform the low frequency waveform into the pattern. Even a squarewave will produce stepped patterns, as the pattern is basically created by a weighted sum of delayed squarewaves with different levels.</p>

<p class="pBody" ps="Body" origtag="Body">When two mixers are connected to the shift register outputs it is possible to create two simultanious but differing patterns. These patterns can e.g. interactively be brought closer to each other or made to differ more. Experimenting is of course necessary to find out how this technique can be used best in a certain musical context.</p>

<p class="pBody" ps="Body" origtag="Body">The convolving filter from the previous example can be used on audio signals, but its effect will be limited to the very high frequency range. Luckily there is a practical application as a part of an equalizer. Applying subtle EQ in the very high with the purpose to shape the sound of cymbals, hihats and the sybilants in voices is difficult, if at all possible, with standard EQ’s. Mostly there is only a high shelving EQ control available, but this only set level and does not do much tonal shaping. To use a convolving filter to shape the high only a short delay with a few taps is needed. The convolving filter that was use to change sequencer patterns can be run at 48kHz by supplying it with a clock signal at that rate. On the G2 it is easy to patch such a clock, only one logic inverter module is needed. By connecting the output to the input of an inverter module it will change in a pulse generator that runs at exactly half the sample rate. Standard sample rate for this module is 24kHz, but by connecting the input of the other inverter on the module to any red output the module will change to orange and run at a sample rate of 96kHz. The pulse clock will now increase to half the 96kHz sample rate and so produce a clock at 48kHz. This is perfect to drive the shift register module at audio rate. Sonically the best results are produced when the filter is used in symmetric mode and so an odd number of taps are needed. One extra tap can be created by adding another sample and hold module in front of the shift register and clocking it with the same 48kHz signal. There are now nine taps that will form a filter with five parameters to set, which is an easy number of knobs to handle interactively. The bandwidth is 48kHz divided by the number of taps, so the filtering action will mainly be between 5kHz and 20kHz. The effect on this band wll be quite dramatic and the tonal shape of e.g. cymbal and snare sounds can be precisely controlled. The knob on the middle tap will pass the clean high signal, of only this knob is fully opened there is no filtering action. By slowly tweaking the other knobs the very high region of the sound can now be EQ’d. By using a crossover filter set to 5kHz before the convolving filter and feeding the low band clean to the output the convolving filter will only work where it should. It is important to give the low band a slight delay equal to the delay of the middle tap of the convolving filter. This can be done with the clocked delay modules, that should be clocked with 48kHz as well and be set to 5 taps. The audio will now pass at a 48kHz sample rate, but as there are no dynamic modulations involved there will be no apparent difference in sound to a 96kHz sample rate, and note that 48kHz is still the professional DAT sample rate.</p>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="FeedforwardFeedback_7616_1000096"></a>Feedback</h3>

<p class="pBody" ps="Body" origtag="Body">Feedback is when a signal is split into two paths and one path is fed back and mixed with the original signal on an insertion point <font class="c_Override" cs="+Override" style="font-style:italic;">before</font> the split is made. This insertion point is made by inserting a two input mixer at the point in the signal chain where the feedback will have to be applied. </p>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="FeedforwardFeedback_7616_1000678"></a>Integration and lowpass filtering</h3>

<p class="pBody" ps="Body" origtag="Body">The most simple example of feedback is when the output of a mixer module is fed back to one of its inputs. On an analog system this would probably immediately cause a race state and quickly clamp the mixer output at the positive or negative power supply voltage. But on a digital system something else and actually very useful happens, as in a digital system there will be a delay of at least one sample in a feedback loop. The explanation of the effect caused by this very short time delay is a little technical, so prepare yourself for the next paragraph. First thing to note is that when modules in a digital system are calculated, it is common to store the module output values in memory locations named output registers. Other modules can read these memory locations later and use the found values as input values. Second thing to note is that digital mixer modules make use of only one single DSP command for each mixer input, which will do a multiplication of the channel input value with the mixer input attenuation value set by the mixer knob for that input, and automatically add the result to a temporary output accumulation register. The effect is that the addition of one scaled mixer input value to the final output value is done by only one combined multiply/accumulate instruction and e.g. a three input mixer will just execute three of these instructions in a row to produce the final output value in the temporary accumulation register. Only after these three instructions are executed is the final output value stored from the temporary accumulation register to the mixer module output memory location where it can be used by other modules. This means that when there is a feedback of the output to one of the inputs of a mixer module it will always use the mixer module output value of the previous sample, simply as the intermediate output value is still in the temporary register and not yet stored in the final output register. This will cause the one sample delay in the feedback loop. The sample that is currently calculated is commonly named the Z sample, and the previous sample is named the Z-1 sample. So, the feedback on the mixer input will use the Z-1 sample. The effect of this very small time delay is that the feedback will now cause an effect named integration. In essence integration is an averaging effect, as the Z sample will contain an average of a whole series of previous samples. Lets take as an example a feedback of 50%. This will cause the Z-1 sample to have an effect of 50%, the Z-2 sample an effect of 50% of 50%, the Z-3 sample an effect of 50% of 50% of 50%, etc. Theoretically all previous samples up to the sample that is an infinite time ago would have some effect, the effect decreasing proportional to the age of the sample. In practice the mathematical precision or resolution of the digital system will put some limit to this time. The sonic effect of averaging caused by integration is a shallow lowpass filtering. The reason why this results in lowpass filtering is because the cycle of a high frequency is much shorter as the cycle of a very low frequency. And as the effect of the averaging is much stronger on recent samples as on samples that passed a long time ago, the effect on high frequency cycles is simply greater as on low frequency cycles. So, not only does the actual values get averaged out, frequency partials also get averaged out, and high frequency partials much more as low frequency partials. Which is exactly what a lowpass filter does. The more the feedback approaches unity gain, the lower the cutoff frequency of the filtering action will be as the averaging is active over a much longer time. This all simply means that feedback of a mixer output to one of its inputs will cause a high frequency damping in the mixer, and this can be put to good use. But as the feedback will also create a build up of energy in the feedback loop, the other signal input must be attenuated. This attenuation is necessary as the feedback loop increases the overall gain for all the channels on the mixer. And too much gain will cause the output signal to hit the headroom of the digital system, resulting in clipping. Luckily it is quite easy to figure out what the attenuation on the other inputs must be, as the relation is linear. E.g. when the feedback is 50% on a two input mixer, the other input should be attenuated by 50% ,and for 75% feedback the other input should be attenuated to 25%. So, the amount of feedback plus the attenuation on the other input should add up to 100% to pass the other input with unity gain to the output. In practice the gain for the other input will in fact never be fully unity gain, as the mixer now also act as a lowpass filter. This causes the gain for each partial that is present on the other input to differ from the gain for other partials, the higher the frequency of the partial the lower the gain. Very low frequency partials will however be passed with almost unity gain.</p>

<p class="pBody" ps="Body" origtag="Body">When a two input mixer is set up with a feedback loop as described, it turns into what is named an <font class="c_Override" cs="+Override" style="font-style:italic;">integrator</font>. To work properly an integrator must work with that Z-1 sample, if the feedback delay is more than that one sample it doesn’t work reliably anymore.</p>

<p class="pBody" ps="Body" origtag="Body">If an integrator is placed within another feedback loop it will cause a very useful high frequency damping in this other loop and can additionally prevent the feedback loop to exceed unity gain. This will make another feedback loop much more stable and reliable. The high frequency damping will additionally allow for a more natural sound, as in a way it mimics the high frequency damping when a soundwave travels through the air. Such a damping is caused by atmospheric circumstances, like e.g. the moist in the air, which forms a resistance that is greater for higher frequency partials in the soundwave. Additionally, the human mind focuses more easily on high frequency partials, and some high frequency damping will shift the attention to the frequencies in the midrange, which can help in creating a more balanced mix where the mind’s attention is guided to where the melody or the articulation is happening.</p>

<p class="pBody" ps="Body" origtag="Body">The actual amount of high frequency damping caused by the integrating mixer is depending on the sample rate, when the sample rate is 96kHz like on the G2, a pleasant amount of damping is created with a feedback of around 75% and an attenuation of the other input of about 25%. These values can be a good starting point to find the balance that works best in a certain application. As a rule of thumb a feedback loop by default needs damping. And consider the few cases where damping can be omitted only as exceptions to this rule.</p>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="FeedforwardFeedback_7616_1000675"></a>Stability issues</h3>

<p class="pBody" ps="Body" origtag="Body">Before looking at more applications for feedback it is important to note that there are two unwanted effects that can appear when applying feedback. The first is a possible severe overload and/or clipping, the second is a possible high frequency oscillation. If one is aware of these possible effects and takes proper precautions it is easier to patch stable feedback systems that work just like expected.</p>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="FeedforwardFeedback_7616_1000590"></a>Preventing overload in a feedback loop</h3>

<p class="pBody" ps="Body" origtag="Body">Feedback is much more critical than feedforward, as when the feedback signal is not properly attenuated it might build up to the headroom of the system, and finally try to exceed the headroom limits. If a small DC component is present in the input signal to a feedback loop the DC component will build up in the loop and shift the output signal substantially towards one of the headroom limits. This can cause clipping to occur much earlier than expected. The way to solve this problem is to insert a highpass filter set to a very low frequency into the feedback loop. The highpass filter will block any possible DC component as a DC component has a frequency of 0 Hz and a highpass filter will always infinitely attenuate a frequency of 0 Hz. In addition to the DC blocking action the highpass filter can also act as a low frequency cut to prevent a muddy sound in the bass octaves. The cuoff frequency can be set between 40 Hz to 120 Hz, depending on the amount of low cut that is wanted.</p>

<p class="pBody" ps="Body" origtag="Body">On an analog system and when there is no time delay in a feedback path, the energy in the loop will build up immediately towards the headroom limits of the system if feedback is over unity gain. Such a superfast build up is named a race state and can occur quickly on analog systems. Here, a feedback gain that is just slightly above unity gain can almost instantly cause the energy that goes around in the feedback loop to explode. Many times an explosion of energy in an analog feedback loop will simply clamp the output signal permanently to either the negative or positive supply voltage of the electronics and keep the output there, resulting in actual silence. Feedback on an analog system is much more tricky as on a digital system, as it is quite difficult to set a high feedback level without accidentally cause the feedback to exceed unity gain. Some analog components exhibit a saturation effect, which in practice means that they act as a signal limiter to keep the feedback level in check. Examples are the cheaper VCA circuits, vacuum tubes or e.g. magnetic recording tape. These components can prevent clamping in the feedback loop, but will generate a lot of harmonic distortion. In some styles of electronic music however this type of distortion is highly valued for its grungy character. Digital systems lack an inherent saturation effect and is acually tricky to implement, one of the reasons why digital systems can react different to analog systems when using patches that employ feedback.</p>

<p class="pBody" ps="Body" origtag="Body">In general, to prevent overload and/or clipping it is important to keep the feedback gain just below unity gain. But even then clipping can occur, in which case the input signal must be attenuated to a much lower level, sometimes some 10 dB to 20 dB below a normal input level.</p>

<p class="pBody" ps="Body" origtag="Body">When there is a relatively long time delay in the feedback loop, like with a long echo delay, there might be enough time to attenuate the feedback signal manually before the loop explodes and overloads. It is also possible to use a compressor or AGC (automatic gain controller) circuit in an echo feedback loop. Compressors are not ideal as they can easily  introduce a pumping effect in an echo feedback. An important thing to keep in mind is that there is always a slight time delay before the compression takes effect. This is true for both analog and digital systems. The effect of the time delay is that fast attacks in e.g. percussive sounds are hardly affected by the compression. Varying the signal level that is fed into the compressor will change the sound and snappiness of the attacks. This is a great sound manipulation to tweak the percussive timbres, but it is in general unwanted on a compressor that is applied in an echo feedback loop. An AGC circuit is in general much slower as a compressor, it might take a few seconds to settle on the wanted signal level. In practice this makes AGC circuits a bit more useful in echo feedback loops compared to compressors. Another method to limit the gain in the feedback loop is to use a tape saturation emulation circuit. Such a circuit works almost immediately, but will also cause a lot of odd harmonic distortion. This type of distortion is typical for magnetic tape, and so this method is very useful to recreate the effect of a vintage tape echo device. Another possibility is to use an analog VCA circuit in an external echo feedback loop of a digital delay unit and tweak the VCA in a way that there is just the right balance between the limiting effect and the odd harmonic distortion. For this application it can be expected that cheap quality VCA modules work out better as expensive ones.</p>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="FeedforwardFeedback_7616_1000467"></a>Preventing high frequency oscillation in a feedback loop</h3>

<p class="pBody" ps="Body" origtag="Body">If in a digital system the feedback signal is over unity gain or is treated by a non-linear function, the feedback can cause severe oscillation at half the sample rate. It is the short time delay of at least one sample between input and output of the circuit that can cause this unwanted high frequency oscillation. Note that the feedback signal at the input must always use that previous Z-1 output sample, and so a one sample delay is inherent. Because the feedback loop in a digital system is inherently also a lowpass filtering function because of this Z-1 delay in the feedback loop, the inherent lowpass cutoff frequency is increased when the amount of feedback is increased. And at high feedback levels the lowpass filtering also becomes more resonant. So, if the feedback level approaches unity gain the resonance is very high at a resonant frequency at about half the sample rate. So, even if the feedback is below unity gain the loop can exhibit a ringing effect when resonance becomes high, but will not yet go into self-oscillation. The obvious way to solve possible ringing or self-oscillation at half the sample rate is by using <font class="c_Override" cs="+Override" style="font-style:italic;">damping</font>. There are two ways to implement damping. The first is to simply attenuate the feedback signal to well below unity gain, but this is probably not what is wanted. The second way is to create a frequency dependent damping, notably <font class="c_Override" cs="+Override" style="font-style:italic;">high frequency damping</font> or <font class="c_Override" cs="+Override" style="font-style:italic;">bandwidth limiting</font>. It is a good idea to look at a feedback loop as a model of a self-controlling system that is in a balanced state. Input will try to get the system out of balance by causing it to ring or go into self-oscillation on a natural resonance frequency inherently present in the feedback system. The purpose of damping the feedback loop is to suppress the natural resonance frequency of the system, making it easier to maintain the balance in the model. This means that the gain of the feedback loop must be made frequency dependent, but without causing extra phase shift that could create a new resonant frequency. As a rule of thumb a 6dB lowpass filter in the feedback loop, set to 5% of the sample rate or the natural bandwidth of an active analog component like an operational amplifier, will make the feedback loop stable enough for most purposes. On a digital system with a 96kHz sample rate the lowpass filter can be set to 5kHz, which also helps in giving the feedback signal a nice, warm sound. But the main purpose is to make the loop stable, it is just a nice bonus if it sounds warm.</p>

<p class="pBody" ps="Body" origtag="Body">Anyway, when applying feedback the main concern is to have absolute control over the amount of feedback. If this control is properly taken care of, which in practice means that for any frequency partial in the feedback signal the loop gain will never exceed unity gain and feedback decreases slightly for higher frequencies, feedback will help to create a number of musicallly very useful effects, like the resonance in filters, deep phasing effects, tube-like harmonic distortion, naturally decaying echoes, early reflections in room simulations, reverberation, etc.</p>

<p class="pBody" ps="Body" origtag="Body">An important thing to keep in mind is that there is always a slight time delay before the feedback takes effect. This is true for both analog and digital systems. It is this short time delay that can cause unwanted high frequency ringing or oscillation even if the feedback is below unity gain, basically because any feedback loop will always have a natural resonance. </p>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="FeedforwardFeedback_7616_999909"></a>Selfmodulation</h3>

<p class="pBody" ps="Body" origtag="Body">Selfmodulation is when the output of a module is connected to a modulation input on the same module. This is in essence also a feedback loop. But the effect of this feedback does not have to be linear, like it is with the integrating mixer. Depending on the type of module, this feedback can in fact be highly nonlinear. An example is when the output of a sinewave oscillator is fed back to its linear frequency or phase modulation input. Such a feedback connection is potentially chaotic, if the feedback level exceeds a certain level the output waveform will change into a chaotic signal. Such a signal is very close to noise, but it produces a very complex waveform that actually repeats. Basically this complex waveform denotes a state of balance. If the feedback amount is slightly changed the waveform will apparently change at random for a while until it gets stuck into another state of balance, where it will produce another complex but repeating waveform at a different frequency. In addition to the purely chaotic behaviour there is an additional tendency to resonate at half the sample rate if there is no damping applied in the feedback loop. Both effects actually influence each other and this can cause the resulting noisy signal to sound quite harsh and unpleasant. What happens in this example is that when a feedback loop is applied on this phase-modulation oscillator, no matter how much signal is fed back, the oscillator will always output a signal that is never higher in amplitude as the original sinewave it generates without modulation. So, the gain in the loop can be well over unity gain, as the nonlinear sine function in the oscillator always ‘folds’ the modulation signal back into a normal output level range, no matter the depth of the selfmodulation. Meaning that the output signal level can never explode. Instead of exploding it will start to create chaotic behaviour. This chaotic behaviour is deterministic, it is not purely random. It follows all the rules of what is known as the Chaos Theory, that tries to describe chaotic behaviour in natural processes. Chaotic behaviour normally develops through what is named waveform period doublings or <font class="c_Override" cs="+Override" style="font-style:italic;">bifurcations</font>. These bifurcations can create musically quite useful subharmonics. But the tendency to resonate at half the sample rate will destroy the predictability of the occurance of these period doublings. Inserting an integrating mixer in the feedback path will dramatically increase the stability and predictability of the development of the chaotic process, as the integrating mixer will suppress the tendency to resonate at half the sample rate. The high frequency damping effect of the integrating mixer will in most cases be much less significant to the final result compared to the tendency to resonate. How to create sounds with subharmonics based on bifurcations will be described somewhere else in this book.</p>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="FeedforwardFeedback_7616_1000078"></a>Summary</h3>

<p class="pBody" ps="Body" origtag="Body">Feedforward and feedback are very important techniques that are easy to patch yourself on a modular system. They allow you to build all sorts of the more advanced sound processing techniques and can give much more control over the final sound. Feedforward can be used to apply an effect to only a part of the sound spectrum by first creating a crossover filtering effect. Another use is to create lively timbral effects caused by interference between the two or more parallel signal paths. Convolution is the most advanced type of feedforward, but on realtime systems it is at present limited to just a few simple applications. Feedback is used on a multitude of techniques, ranging from creating very soft or strongly resonant filters to echo delays and selfmodulation on oscillators. Feedback is also used in physical modelling where it is used to let energy recirculate in waveguides, which are short audio delay memories with the length of exactly one cycle of a waveform at the played pitch. These physical modelling techniques will be explained in a later chapter.</p>

<p class="pBody" ps="Body" origtag="Body">&nbsp;</p>




















</body></html>
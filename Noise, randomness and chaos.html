
<!-- saved from url=(0095)https://web.archive.org/web/20240614203402fw_/https://rhordijk.home.xs4all.nl/G2Pages/Noise.htm -->
<html><!--<meta version="1.0">--><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><script type="text/javascript" src="./Noise, randomness and chaos_files/bundle-playback.js" charset="utf-8"></script>
<script type="text/javascript" src="./Noise, randomness and chaos_files/wombat.js" charset="utf-8"></script>
<script>window.RufflePlayer=window.RufflePlayer||{};window.RufflePlayer.config={"autoplay":"on","unmuteOverlay":"hidden","showSwfDownload":true};</script>
<script type="text/javascript" src="./Noise, randomness and chaos_files/ruffle.js"></script>
<script type="text/javascript">
    __wm.init("https://web.archive.org/web");
  __wm.wombat("https://rhordijk.home.xs4all.nl/G2Pages/Noise.htm","20240614203402","https://web.archive.org/","web","https://web-static.archive.org/_static/",
	      "1718397242");
</script>
<link rel="stylesheet" type="text/css" href="./Noise, randomness and chaos_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="./Noise, randomness and chaos_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->
<title>Noise, randomness and chaos</title>







<!--<base target="_self">--><base href="." target="_self">

<link rel="stylesheet" href="./Noise, randomness and chaos_files/Default.css" type="text/css">

<link rel="stylesheet" href="./Noise, randomness and chaos_files/IntroHistory_4835.css">


<link rel="stylesheet" href="./Noise, randomness and chaos_files/Custom.css" type="text/css">

<meta name="generator" content="RoboHELP by eHelp Corporation - www.ehelp.com - from RoboHelp for FrameMaker">

<link rel="next" href="https://web.archive.org/web/20240614203402fw_/https://rhordijk.home.xs4all.nl/G2Pages/LevelProcessing.htm">

<link rel="prev" href="https://web.archive.org/web/20240614203402fw_/https://rhordijk.home.xs4all.nl/G2Pages/ResFilters.htm">


</head>



<body>







<!-- Generated Text- - - - - - - - - - - - - - - - - - - - - - - - - - - - -  -->

<h2 class="pHeading1" ps="Heading1" origtag="Heading1"><a name="Noise_3374_999209"></a>Noise, randomness and chaos</h2>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="Noise_3374_999212"></a>Noise</h3>

<p class="pBody" ps="Body" origtag="Body">By definition noise is an audio signal that consists of an accumulation of sinewaves of all the possible frequencies in the hearing range and with all possible amplitudes and phase relations. Musically a noise signal can be seen as the opposite of a sinewave signal, as a sinewave signal contains only one single frequency component while noise contains every possible sinewave component. When used as a sound source for subtractive synthesis, noise has some interesting properties. Consider the thought that by filtering noise every possible sound might be created, as that sound should be hidden somewhere in the noise. This idea can easily grab the imagination and in the fifties of the last century composers started to experiment with audio processing of noise signals, trying to destill specific sounds from the noise signal. It soon became clear that there are two reasons why it is virtually impossible to filter every possible sound from noise. The first is that this would require filters with a quality that simply does not yet exist. The second and more important reason is that when the frequencies are filtered out correctly the amplitudes still vary wildly, making it virtually impossible to create steady tones. Still, filtering noise does open a whole range of sounds that often have a spatial, almost eerie nature, just because of those wildly varying amplitudes. Much of the electronic music of the late fifties and early sixties is characterized by sounds made by processed noise signals, e.g. by tuning a couple of sharp bandfilters to chords and use these bandfilters in parallel to filter the noise. Noise is still a very important sound source for creating sound effects and to add 'breath' to sounds that mimic wind instruments or enharmonic sounds like cymbals and percussion.</p>

<p class="pBody" ps="Body" origtag="Body">A typical example of how noise can be generated is by amplifying the thermal noise in the semiconductors used in an analog circuit. Thermal noise is inherently present in every analog electronic device, e.g. the faint noise that is heard when fully opening the volume control of an amplifier while there is no sound at the amplifier input. In this type of noise each partial appears and disappears in no apparent order. Many noise generators in analog synthesizers use a semiconductor device like a diode as the part that produces the noise. By driving a small current through the diode, thermal quantum effects appear at the junction of the diode device, creating a very faint noise signal which is then heavily amplified to bring it to line level. This type of analog noise sounds very lively as the amplitudes and phase relations of each partial change all the time.</p>

<p class="pBody" ps="Body" origtag="Body">Noise has no apparent pitch. Now, pitched sounds can be described exactly by the momentary frequency and harmonic content. But unpitched sounds don't let themselves be described that easily, just as there would be too much partials to describe. Instead, noise signals are descibed by either how much sonic power is in certain frequency ranges or by the statistic probabilities for certain frequencies to appear. The simplest case is when each possible frequency has an equal chance of occurrence, which in statistical terms is named an equal distribution. When a noise signal has an equal distribution, it sounds like a very bright hissing sound where the higher parts of the audio spectrum are clearly much more pronounced as the lower parts. The timbre of noise is often reffered to by a colour and equal distribution noise is commonly named white noise. Still, there is no real physical relation to white light, the association with a colour is just to give a name to the timbral character of the noise signal. The reason why white noise sounds very bright is because the equal distribution of possible frequencies is on a linear frequency scale, but the ear hears pitches on an exponential scale. Remember that each higher octave means a doubling of the frequency values, so transposing a pitch by three octaves means in this case an increase of the frequency by 2^3 or making the frequency eight times higher when expressed in Hertz or cycles per second. What this implies is that in white noise the sonic power in each octave band in the hearing range also doubles for each higher octave band, just as there are twice as much frequencies in that higher octave. So, there will be much, much more high frequencies in the highest perceivable octave band that in the lowest perceivable octave band, which accounts for the bright hissing timbre. When noise is processed by filters to create specific sounds it is often more useful to reduce the sonic energy in each higher octave bands to prevent higher pitched sounds to be overly loud compared to the lower pitched sounds. This means that when the frequency doubles, the possible range of amplitudes should become smaller. Basically this can be done by filtering white noise with a lowpass filter set to the lowest audible frequency and amplifying the filtered signal until it is at line level again. When using a 6dB lowpass filter he timbre of this type of noise is named red noise, as it sounds quite dark. Like white noise sounds overly bright, red noise sounds overly dull. To the ear, the noise timbre that is perceived as neutral is somewhere in between white noise and red noise and is named pink noise. Pink noise sounds very pleasant, it appears to have a timbre like the sound of a distant ocean surf. When analyzing the spectrum of pink noise it turns out that the sonic power decreases by 3dB in every next higher octave. Statistically this means that a frequency has a probability of 1/f. The interesting thing is that there are many natural phenomena that occur with a statistic probabililty that also exhibits this 1/f or -3dB per octave curve. Not only our ears, but nature itself seems to like pink noise rather well.</p>

<p class="pBody" ps="Body" origtag="Body">Pink noise can theoretically be made by filtering white noise with a lowpass filter with a 3dB cutoff slope where the cutoff frequency is set to the lowest perceivable frequency, so the cutoff slope is a straight -3dB declining line over the whole frequency range. Technically it is not at all that easy to make a filter with a perfect 3dB cutoff slope, as there is no one singular filterblock known that exhibits such a slope. In practice it turns out to be very complex to generate a perfect pink noise signal. Which means that in general a method is used to approximate as closely as possible the -3dB curve, where perfection is traded off with complexity. Musically the easiest way to make good sounding 'pinkish' noise is to use two parallel allpass filters tuned to around 200 Hz and 2kHz, where a certain mix of the two filter output signals with the original signal roughly estimates the timbre of pink noise.</p>

<p class="pBody" ps="Body" origtag="Body">There are more types of noise that received the name of a colour to quickly grasp their basic tmbre. Blue noise has a slope of +3dB, in contrast to pink noise the higher frequencies in blue noise are amplified instead of attenuated. Blue noise appears to the ear to have no low frequencies at all. 'Brown' noise is a very dark sounding type of noise and is actually derived from what is named Brownean motion, a signal that is made by randomly adding or subtracting a small fixed value to the previous value. This is also referred to as a random walk signal, as each new value is 'the length of one step' away from the previous value. Brownean noise is often used to generate slowly varying control voltages.</p>

<p class="pBody" ps="Body" origtag="Body">The spectra of white, pink, red, blue and Brownean noise all have a smooth slope that is either horizontal or slightly tilted. Next to these common types of noise signals there are some more specialized types of noise. These special types are characterized by spectra that in fact contain a number of well defined frequencies, but these are tuned in a way that the human brain can not determine a dominant pitch. A good example is a type of noise that is named bronze noise or metal noise. This type of noise contains strong partials that sound very much like cymbals. This noise is created by mixing a couple of oscillators with harmonic rich waveforms. The oscillators are tuned in a way that the common fundamental of their mix lies below 16 Hz, so the mind cannot perceive this fundamental anymore. As the ear cannot hear pitches that are below about 20Hz, the mind has no reference to imagine what such a pitch would sound like, similar to how the mind cannot imagine what infrared or ultraviolet light looks like. It is basically the harmonics of the oscillator waveforms that create a sound with a pitchless sensation, but with a distinctly different timbre from white noise or pink noise. A good example is the metal noise used for the cymbal sounds in the Roland TR808 analog drumcomputer. In this drumcomputer the noise is generated by a mix of six squarewave oscillators tuned to roughly 210 Hz, 320 Hz, 380 Hz, 540 Hz, 550 Hz and 800 Hz. The lowest common denominator of these frequencies is 10 Hz, which means that the fundamental pitch of the mix is at 10 Hz. The pitchless sensation is enhanced by highpass filtering with a 12dB highpass filter, a cutoff at around 1600 Hz seems a good value.</p>

<p class="pBody" ps="Body" origtag="Body">Curiously enough it is not easy to produce good sounding noise with digital techniques. The simplest way to create digital noise with discrete digital chips is with a circuit based on a shift register. A shift register is sort of a pipeline that can hold a sequence of bits. New bits can be shifted in at the left side of the pipeline causing the bits that are already in the pipeline to shift their positions one location to the right by command of a clock pulse. The status of the new bit that is shifted in at the left can depend on a rule of what to do when two or more bits in the shift register form a certain combination. By combining those bits with an exclusive OR function, a rule that produces a zero value if both bits are equal and a one value if the bits are unequal, a sequence of numbers can be generated that appears to be random. All the bits in the pipeline together form a binary number that is used as the output. As the number of bits defines the possible amount of numbers that can be represented, e.g. eight bits can produce 2^8-1 = 255 numbers, the sequence will eventually repeat itself exactly. Real randomness never repeats, so this shift register algorithm is aptly named a pseudorandom number generator and in fact it produces a periodic signal. But when the pipeline uses 48 bits that are clocked at a samplerate of 96kHz, one period lasts somewhat over 92 years, so only few of us will live to hear it repeat. The disadvantage of the shift register method is that the random signal seems to have little motifs, short arpeggio-like figures caused by the delay in the shift register before the bit that shifts into the register will actually influence the feedback signal. When a system has a multiplication possibility another algorithm named the linear congruential method can be used. This method gives slightly superior results over the shift register method, as it lacks the short arpeggio-like figures. The linear congruential method uses the formula x' = (a * x - b) mod c, where a and b are well-chosen prime numbers and c defines the range.</p>

<p class="pBody" ps="Body" origtag="Body">The advantage of pseudorandom number generators is that they can be preset to a certain number defining the startposition in the sequence. From there on they will proceed in a well defined way, but so complex that the sequence will appear to be random to out ears. Another advantage is that every possible number will appear only once during one period of the sequence with the parameters for the algorithm are properly chosen. This means that the numbers have an equal distribution and the timbre of the sound produced by the algorithm is equal to pure white noise. An algorithm that produces pink noise is much more complex to implement, basically because noise is not about generating random numbers but generating an unlimited amount of frequencies that all have a chance of appearing depending on their frequency. As mentioned before the chance of a frequency f to appear is 1/f for pink noise. Most algorithms to generate digital pink noise algorithm are very complex, too complex to be easily implemented in a current state of the art digital synthesizer without eating away all the computational resources. The difficulty is in the fact that it is not the statistical distribution of numbers that defines the timbre, but the statistical distribution of frequency partials. Just like with analog pink noise it is best to approximate digital pink noise by the same methods, e.g. by applying the earlier mentioned dual allpass filtering method on a properly chosen pseudorandom number generation algorithm pink noise can be created that is of sufficient quality to be used for musical purposes.</p>

<p class="pBody" ps="Body" origtag="Body">To filter specific sounds from noise the basic colour of the noise used as the sound source is very important for the final effect. In practice it turns out to be very difficult to judge the timbral quality of the noise source by ear. In everyday life there are noises all around us and many of these noises are unpitched. Examples are natural sounds like the whistling and hissing of the wind or the flow of a stream of water. Or man made sounds like the noise of cars running down the road. These sounds have specific characteristics by which they can be instantly recognized. The human mind has a tendency to suppress these sounds from our awareness after a while and somehow listening to the sound generated by a noise generator seems to slightly confuse the brain. The effect is such that when steady noise is heard it is difficult to remember how noise of another colour actually sounds like. This is a psychoacoustic phenomenon that might have to do with how the brain tries to suppress background noises, with how in normal life a continuous noise sound, like e.g. the ocean surf heard from a medium distance, would quickly be suppressed in the human awareness. To judge the sonic qualities of noise there is a simple trick that involves a vocoder. When a noise signal is fed into both inputs of a vocoder the noise sound will be transformed into a sound that is immediately associated with rain or a running stream of water. Pink noise and a good quality vocoder will give a very convincing sound of a running stream, in fact the more convincing the better the quality of the vocoder. While the vocoder produces the character of running water or falling drops of water, the colour of the noise will define the association with a certain natural phenomenon. White, pink and blue noise might sound like rain, a fast running stream from a short distance, a slow running stream from a long distance, a quietly babbling stream, a high pressure jet of water, etc. Red and Brownean noise will sound more like thunder from a distance or an earthquake. Just as the association is quite clear it makes it a lot easier to judge if the noise is suited for the particular use in mind. So, the vocoder will reveal specific qualities that are hiding in the unprocessed noise and the sound from the vocoder can give some guidelines on what to expect when doing other filterings. It is also a good trick to judge the quality of a vocoder.</p>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="Noise_3374_999225"></a>Randomness</h3>

<p class="pBody" ps="Body" origtag="Body">Randomness is closely related to noise. Noise is an audio signal, but randomness has many times to do with musical events, like when certain notes are being played or how a control signal doing a modulation develops. Basically randomness is about making choices, e.g. a musical event like a note is about to happen and for this upcoming event a choice for a specific parameter must be made out of a limited or unlimited amount of possible choices. Note that possibilities can always be clearly defined by a set of rules. This is a bit the difference between noise and randomness, noise is audio with a certain static timbre that can be processed, but randomness involves making active choices from a certain set of alternatives. Next to random choices, where the choices are made on discrete moments in time, there is the possibility of a continuous control signal that develops in an uncertain way. With such a continuous random signal the choice on how to proceed the development is made continuously. There is some subtlety involved in the definitions here, some might say that they don't make choices as they simply use a module that produces something random and that's it. But randomness always implies the possibility of choices according to rules and choosing not to make choices is in itself already a choice that is part of the possible choices. It is just the simplest choice one can make.</p>

<p class="pBody" ps="Body" origtag="Body">On an analog synthesizer there can be an output on a noise generator named random voltage. The signal that comes from this output is a slowly varying control signal and is in fact a subsonic noise signal. In general this noise signal is lowpass filtered from white noise or pink noise in a way that there are no more frequencies in the audio range present, but all frequencies that are present are actually in the subaudio range. It is comparable to the signal from a low frequency or modulation signal oscillator, but instead of producing a well defined periodic waveform the random voltage signal just seems to wander aimlessly between a minimum and a maximum limit. There is some sense of speed in the signal, it can slowly change in a relaxed rate or variate wildly at a fast rate. A musically important property for a random control signal is how the apparent rate or the slope of the signal accelerates and decelerates. The reason is that acceleration and deceleration of tempi can be important means to give music a human feel. Acceleration and deceleration can also give modulations a sense of going somewhere, which might increase tension in an abstract electronic music composition. When a continuous random control signal is created by filtering noise with a lowpass filter there is no specific acceleration and deceleration as a parameter to be controlled. It is fully up to chance how the signal will develop. Brownean noise is an exception, as with this type of noise the momentary signal depends on the choice of how the previous state changes by either adding or subtracting a specific number. The value of this number can be manipulated depending on certain rules and this opens up the possibility of controlling acceleration and deceleration by a parameter. This is very complex to do with analog electronics, but a computer can easily run an algorithm where a controllable acceleration parameter is implemented.</p>

<p class="pBody" ps="Body" origtag="Body">When random choices have to be made on specific moments, like varying the initial phase relation of two unisono oscillators on a keypress to give each played note a slightly different character, a random value has to be picked from somewhere. The common way to do this is to use a S&amp;H; (Sample &amp; Hold) module that can measure the momentary value of an input signal on a clock pulse command. The value is stored internally and presented on the output as a fixed value that stays fixed until the next clock pulse command is given. A S&amp;H; module is best seen as a memory cell that can measure and memorize an analog value. But next to being a memory cell the S&amp;H; is also an important synchronizer module, as every store operation is synchronized to the clock signal that commands the S&amp;H; to memorize and store the input value. When a S&amp;H; receives a series of clock pulses at a certain rate there will be statistic properties in the sequence of output values. And these statistics depend fully on statistic properties of the input signal. When using a noise signal to be sampled the output values will be a series of unpredictable random numbers. Although there is a big difference in sound between white and pink noise, there will not be such an apparent difference in the generated series of numbers when sampling either white noise or pink noise with a S&amp;H.; Much more apparent is differences in how the amplitude of the input signal deviates around zero. When using a S&amp;H; the rule of thumb is that the distribution of momentary amplitude values is of more importance than the distribution of possible frequencies in the signal to be sampled. There is some sense to this, a S&amp;H; samples amplitude values and not frequency values.</p>

<p class="pBody" ps="Body" origtag="Body">To get a predictable behaviour it is good to start with a signal where it is known that every possible amplitude value has an equal chance of appearing. The shift register pseudorandom number generator is a perfect choice. The maximum length of the sequence it can produce is 2^n-1, where n is the number of locations in the shift register. The produced value will be in the range from 0 up to and including 2^n-1. E.g. when the shift register is seven locations long the sequence will be 127 steps, and each integer value in the range from 0 up to and including 126 will appear once. To get this range the shift register is fed back with a XNOR function combining taps six and seven from the shift register. There is one combination of bits that can never appear as it would stop the production of new values, this state is if either all bits are zero when a XOR function is used or if all bits are one when a XNOR function is used. Initially the bits will be all zero, so when using a XNOR function one never has to worry about this issue as the number where all bits are one is simply never produced. Let's assume that there is a pseudorandom number available that will do this 127 steps and produce 127 values. This would be quite convenient to play notes when each value represenst a note. Or to produce values that will be used for velocity or a midi CC# to be send to some device, just as midi CC#'s can only handle 127 values. But the pattern that is generated repeats every 127 steps and so doesn't really appear random. Still there should be 127 different sequences possible and when it is possible to sequence through these sequences the total length would become 127 times 127 is 16384 steps before the sequence would repeat. The way to do that is to scramble the order of the basic pseudorandom sequence as generated by the shift register. There are several ways to go about increasing the sequence length, the most obvious is of course to increase the length of the shift register. But as on an analog modular system the shift register is often made by cascading a number of S&amp;H; modules, and there might be just a limited amount of S&amp;H; modules in the system available, it is interesting to look at other options. One option is to make use of the principle of interference. The idea is that the output of the shift register is sampled with an extra S&amp;H; that runs at another clockrate. The frequency ratio between the clock used on the shift register and the clock used on the extra S&amp;H; will define how the sequence gets scrambled into a new sequence. Basically the original pattern and the output of the extra S&amp;H; form an interference pattern. In normal situations one would want the extra S&amp;H; to be clocked by the masterclock that syncs everything in the patch and variate the clock that clocks the shift register. If the shift register clock is faster than the extra S&amp;H; clock there will be a differnt value on every S&amp;H; clock pulse, but if the shift register clock is slower the values will hold for one or more clock pulses. The extra S&amp;H; doesn't need to be clocked by a continuous train of clock pulses like those coming from a tempo masterclock, the clockpulses can also come from e.g. the keyboard gate. This will produce random value on each keypress. because the relation between the moment of the keypress and the momentary shift register value is pretty random the pseudorandomness of the shift register is changed in a real random value, but with the statistical property that each possible value has equal chance to appear.</p>

<p class="pBody" ps="Body" origtag="Body">Sometimes it is wanted to change the statistics of the equal distribution, meaning that the chance for a certain number to appear must be greater than another number. An example is when one wants a sequence of only the notes E, F, G and Bes, but want the statistics to be that the E and G have three times more chance than the G and Bes. In such cases the easiest way is to use a lookup table. If this lookup table has eight locations to store values and three locations are filled with a value that will produce an E note and three locations are filled with a G note value and the resting two locations are filled with the value for the F and the Bes, it suffices to use an equally distributed random number to choose a location in the table to get the right statistics from the table. A synthesizer module that is able to work as such a table is a voltage controlled sequencer. Such a sequencer is not stepped to a next step by a clockpulse, but a control voltage input makes it switch to a certain step. The knob that belongs to a certain step sets the lookup value and the voltage level on the control voltage input will select the value set by the corresponding knob. This type of sequencer usually has eight or sixteen steps on an analog system. On a digital system there might be much more steps available. When using a programming language on a computer a lookup table, or array as it is named in many computer languages, might have many thousands of locations to store lookup values. Lookup tables are a very convenient way to change statistics of a range of values and often works better than trying to figure out some mathematical formula and trying to patch such a formula with mixers and multiplier modules. The output of a lookup table can be used to lookup a value in another lookup table to define complex rules. A use might be to define possible chord progressions. The output of a table can also be used to lookup a value in the same table again, which is in essense equal to a technique named cellular automata. </p>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="Noise_3374_999232"></a>Chaos</h3>

<p class="pBody" ps="Body" origtag="Body">There are many dynamic processes or systems in nature where it can be verified that every current state develops from a previous state and an initial state defines how the whole process will develop. A wellknown example is named 'The Butterfly Effect', or how the movement of the wings of a butterfly in the Amazon Rainforests could start a chain of events that eventually could cause a storm to happen in Oklahoma. In the last thirty years there has been a lot of research on such systems and this research has shown that many of these systems can have several stable states. When in such a state the system is in balance until some influence gets it out of balance and it develops into another stable state until it is disturbed again. These kind of systems are known as chaotic systems, there is definitely a certain order in the system, but the order is many times so complicated that it is simply impossible for a human to grasp how it develops and so it is designated as chaos. Still, the stable states might be well recognized. Chaos generators are of musical interest because they can produce sonic source material that is quite different from the sounds produced by oscillators or noise generators. Don Buchla pioneered the field of chaos generators by designing the Module 265 'Source of Uncertainty' for the Buchla Music Box analog modular system. A more recent chaos generator module loosely based on the Buchla design is the 'Wogglebug' made by Wiard. These modules produce chaotic random voltages and randomly gliding tones. An analog circuit that is truly chaotic is known under the name of Chua's circuit, developed by professor Leon Chua. Chua's circuit is an example of a simple non-linear feedback system where the nonlinearity in the feedback path will create chaotic behaviour. A cimilar circuit has become known as the Cracklebox, developed by Michel Waisvisz and marketed as a little wooden box with a few touchpads. When placing the fingers on the touchpads the box will start to make chaotic crackling noises that to some extend can be influenced by the fingers.</p>

<p class="pBody" ps="Body" origtag="Body">A chaos generator will have attractors that reveal themselves as a short repetitious pattern or sequence. When the generator produces such a repeating pattern it is in a stable state. Such a repeating pattern forms one cycle of a more or less randomly shaped waveform. Only a small variation in a controlling parameter will disturb the stable state and the generator will produce a series of apparently random values until at a certain moment it will get caught in another repeating pattern. It gets literally attracted to that new pattern, hence the name attractor. So, basically the attractor is the pattern the chaos generator will eventually adopt and not a parameter to be tweaked. Byt the tweakable parameters will define to which attarctor the pattern will evolve to.</p>

<h3 class="pHeading2" ps="Heading2" origtag="Heading2"><a name="Noise_3374_1000075"></a>Building a chaos generator</h3>

<p class="pBody" ps="Body" origtag="Body">A Sample and Hold module is at the core of a chaos generator. The output of the S&amp;H; is processed by some modules that must exhibit some non-linearity and the output of these processing modules is fed back into the input of the S&amp;H.; Let's assume that the S&amp;H; is initially filled with some value. This value is changed into another value by the processing modules and as long as the S&amp;H; outputs this initial value the final output value of the processing modules is stable. When the S&amp;H; receives a clock pulse it will sample this final output value and use it on the output of the S&amp;NH; module as a new value to be processed. The processed new value is sampled again, and on every sample clock to the S&amp;H; the value on the output of the S&amp;H; will change. If the processing modules together form a function that is by nature chaotic, a repeating pattern will eventually be produced, the pattern actually depending on the initial value in the S&amp;H.; There are quite a few simple mathematical fucntions that can be easily patched and have the non-linearity that will create chaotic behaviour. The simplest and most well known is the function X' = 4 * X * (1-X), where x is the current value in the S&amp;H; and X' is the result of the calculation that will be sampled in the S&amp;H; on the next clock pulse. The initial value must be between 0 and 1 and the output will always be between 0 and 1 as well, so it is fitted to be the new input again. The whole trick of a chaos generator is to insert the initial value or seed value. To do this a controllable two-pole switch can be used that switches the input of the S&amp;H; between the output of the modules that form the function and a constant value or knob that defines the seed value. The switch must point to the constant for exactly one clockpulse only and a special circuit named a one-and-only-one can be used to generate the single clockpulse. Instead of a controllable two-pole switch a voltage controlled crossfader can be used, but a one-and-only-one module is most probably not present on an analog modular system. Digital modular systems like the Clavia G2 do have all the modules on board to create chaos generators based on a non-linear function.</p>

<p class="pBody" ps="Body" origtag="Body">The attractor or stable pattern a chaos generator will eventually adopt is defined by both the seed value and the non-linear function. Instead of inserting a new seed value on a clock pulse command the non-function can be slightly modified. When the function is modified the pattern will evolve over a short time into another pattern. The easiest way to change the function is to reduce the feedback a little. It shouldn't be reduced too much or the generator might stop to produce new values. The properties of the function should be that the generated patterns should be sufficiently long to be of musical interest, a couple of hundred to a couple of thousand values is convenient. Additionally it should take some time to evolve into a new pattern, again some hundred to a few thousand values is of interest. When the chaos generator is run at audio rates these sequence lengths can produce very characteristic sounds. When it is run at lower rates to create melodic patterns one might go for functions that produce shorter lengths. A function that produces patterns and attractor transitions of sufficient length and additionally produces bipolar values between -1 and +1 is the third Chebyshev polynomial X' = 4 * X^3 - 3 * X. This function is quite easy to program, but if it produces the value 0 it will hang as an input value of zero will produce an output value that is also zero. A zero value is however quite easy to detect and a good moment to automatically insert a new seed.</p>

<p class="pBody" ps="Body" origtag="Body">Another method to produce chaotic sounds is to feed the output of a squarewave oscillator into a lowpass filter and feed the output of the lowpass filter back into a LinFM modulation input of the oscillator. If a LinFM input is not available a pitch control input can be used as well. Without filtering the feedback loop the oscillator would switch between a very fast and a very low frequency, which would cause the oscillator to produce a narrow pulse on its output. The filtering slows this process down in a way that the oscillator can come into a chaotic state. Tweaking the filter cutoff and resonance and the modulation index will produce sounds that are in between the original square wave through a range of semi-random pulsations to a noise signal.</p>

<p class="pBody" ps="Body" origtag="Body">Phase modulation oscillators are also very good to create chaotic patterns, especially if the pitch can be set to zero Hertz, converting the oscillator into a sine function. In this last case a S&amp;H; module is placed between the PM oscillator output and the PM input. If the oscillator is set to a pitch of zero Hz the oscillator changes into a sinewave function. Each clock pulse on the S&amp;H; clock input will put a fixed value on the PM input and the output will be a value that is the sine of that PM input value. As the oscillator is actually stopped by setting it to zero Hz, the output value of the oscillator wil be fixed until the next clock pulse. This patch could produce output values of zero, which would hang the process. To avoid this a fixed value must be added to the oscillator output before it enters the S&amp;H.; The chaotic pattern can be disturbed by small changes in the fixed value. As long as this fixed value is not zero the patch will produce chaotic patterns with attractors and transition periods between two attractors when the feedback is disturbed.</p>

<p class="pBody" ps="Body" origtag="Body">The output of the chaos generator is a stepped signal, but it can be changed into a linear gliding signal by adding a few modules. The idea is that when the S&amp;H; is clocked by the flank of a sawtooth waveform and the output of the chaos generator is fed into a shift register, that is also clocked by the sawtooth flank, a modulatable crossfader can be used to create linear glides between two adjacent outputs of the shift register. The sawtooth signal is used to control the crossfader position. It works like this; when a flank in the sawtooth triggers the S&amp;H;, and so a new value is generated, the output values will shift one position to the right in the shift register. The crossfader will on the flank of the sawtooth immediately crossfade to the previous output value that is now one position to the right, and then crossfade to the new output value that is to its left in the shift register. On the next sawtooth flank this will repeat and so the crossfader will smoothly crossfade between the previous value and the new value, creating glitchless linear glides. This signal can be used as a random glide signal that follows the chaotic pattern of the chaos generator. When e.g. an eight output shift register is used seven crossfader can be used to create seven glides, each glide being a delayed replica of the crossfader that uses the crossfader to its left. These glide signals are very useful to control and modulate all sorts of parameters in a patch. When the sawtooth signal that drives the chaos generator, the shift register and the crossfaders is synced to the tempo clock a whole range of tempo synced glides are created in what is much like a canon. Of course, the chaos generator can be replaced by a sequencer module, a S&amp;H; sampling any waveform or a another type of clocked random signal generator.</p>




















</body></html>